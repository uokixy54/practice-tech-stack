# JavaScriptの歴史

### JavaScriptの誕生
- 1995年にNetscape Navigatorで始めて実装された
- もともとはLiveScriptだった
- 1996年にIEに搭載
    - この当時はIEとNetscapeで独自に機能追加したためそれぞれに合う開発が必要だった
- 1997年にJavaScriptの標準であるECMAScriptが誕生
    - どの実行環境でも共通に動くJSのこと
    - 実際は実装速度に差が出たりするため注意が必要
    - 特にES2015はIEはサポートしていない
- JS起因のクラッシュや悪用ウイルスによってJSの機能をオフにする人が増える
- Ajaxが出たことにより復権
- 2006年にjQueryが誕生
    - コードの記述量が減る
    - ブラウザ間の差異を吸収
- 2009年にServerJSというプロジェクトが立ち上がった
    - 当時は様々なAPIが足りていなかった
    - ブラウザとサーバーで必要なものが異なるため
    - 同年8月にCommonJSに改名
- 名前空間が一つしかないためファイルを分けると読み込み順や１つのファイル変更でプログラムが壊れてしまった
    - 名前空間の問題はモジュールが解決
        - スコープという概念によって解決
        - ただし、Commonjsの話でブラウザのJSでは依然として名前空間の問題が残る
    - 依存関係はパッケージ管理が解決

### Node.jsの誕生
- 2009年にNode.jsが誕生
    - CommonJSのモジュールAPIに準拠
    - CommonJSがあまり機能しなかったためNode.jsは独自に進化していく
    - CommonJS形式のモジュールは残っていくもののCommon.js自体は終了
- パッケージ管理
    - package.jsonで記述されたファイルやディレクトリのことを指す
    - モジュールによって機能ごとに分けられるようになったことで、機能を共有したい需要が発生
    - 共有するためのバージョン管理やシステムからパッケージ管理システムが登場
- パッケージ管理システム
    - リポジトリの購読
    - パッケージのインストール・削除
    - 依存関係の解決
        - パッケージに必要なパッケージを自動でインストール・更新
        - バージョン合わせも自動
    - 設定管理
- 2010年にNode.jsのパッケージ管理システムであるnpmが誕生
    - 名前空間の問題はモジュールで解決
    - 依存関係はnpmで解決
    - ServerJSの準備が完了した

### クライアントサイドのモジュール
- 2009年にAMDという仕様が誕生
    - RequireJSがこの仕様を実装している
    - 依存関係もIIFEよりもある程度解決できる
- 2012年にBowerが誕生
    - クライアントサイド向けのパッケージ管理システム
    - IIFEかAMDモジュールを採用
    - ユーザーが依存関係を定義する必要があった
    - 同一ページで違うバージョンのパッケージ使えなかった
- AMDはサーバー側と互換性がなくCommonJS形式よりも冗長だった
    - ファイルシステムやIOが使えなかった
    - 依存関係が多いとメンテナンスが大変
- ここまでのモジュールまとめ
    - IIFE形式
    - AMD形式
    - CommonJS形式
        - Node.jsでうまくいった
- 考え方が変化
    CommonJS形式で書かれたものを事前にブラウザ向けに変更する
- バンドル（Bundle）
    - CommonJS形式で開発したものを1ファイルに変換する ※CommonJSとあるが実際には他のモジュール形式やCSSなどもバンドルする
    - 変換したのをscriptタグで読み込む
    - 2011年にBrowserifyというツールが誕生
        - 全ての依存関係を束ねてブラウザでrequire分を使用可能にする
        - Node.js同様にブラウザで使える
        - Node.jsのパッケージをそのままブラウザ版に移植された
    - ブラウザでもnpmが使われるようになった
        - CommonJS形式で書かれたパッケージをブラウザ向けに変換できるようになったため
    - 2012年にwebpackが登場
        - バンドルツール
        - JS向けだが対応するローダーがあればHTMLやCSS、画像もバンドルできる
        - 対応するローダーとはJSからそれらを読み込むもののこと
        - Chunkという単位に分割して非同期で読み込むことでロード時間の短縮も可能
- 今までの話はJSの標準実装ではない
- ES2015にES Modulesの誕生
    - 言語の仕様でモジュールが使えるようになった
    - IEではES MOdulesが使えないためバンドラーツールは依然として使われる
- webpackでES Modulesをネイティブサポート
    - ネイティブとはローダーを読み込まなくても平気になった
- モジュールバンドラーがあればCJSやESM形式でモジュールを利用してコードが書ける
    - scriptタグに直接読み込む時代でもモジュールが使えるということ
    - npmも使える
- コンパイル（Compile）
    - ブラウザでは直接動かないものを動くように事前に変換すること
    - ES2015はモジュール以外にも様々な機能が追加された
        - これを古い環境で動くようにするものでBabelが登場
        - ES2015からバージョン落とすなど
    - TSやJSX形式を事前に変換できたりする
    - babelはwebpackと一緒に使えるため新機能をコンパイルしてモジュールや依存関係をwebpackで解決することができるようになった

### ブラウザ戦争
#### 第一次ブラウザ戦争
- 1990年後半にNetscapeとIEが熾烈なシェア争いをしていた
- その結果IEが勝った

### 第二次ブラウザ戦争
- 2000年後半からIE, Chrome, Firefox, Safari, Operaのシェア争い
- 2014年にChromeが勝ち終了

### サーバーJSが登場する前のブラウザサイドのモジュール
- Anonymous closure
- Global import
    - jquery採用
- Object interface
- Revealing module pattern
- 以上はIIFE(即時実行関数)を利用してる
    - 関数式の中に閉じ込める手法
    - 完全ではなかった

### バンドルとコンパイルの違い
- バンドルとは様々なモジュール形式で書かれたファイルの依存関係を解決して1ファイルに変換すること
    - ただしES2015サポートされていればバンドルツールは必要としない
    - CSS等のアセットファイルもバンドルし依存関係や効率的に読むのには使用が好ましい
- コンパイルとは、ES2015など最新の構文でも従来の環境でも動くようにJSを変換すること
    - jsx形式などを事前にjs形式などに変換すること
[バンドル・コンパイルについて](https://qiita.com/kenjirohayashi/items/a759cade74449f51c6bc)

### 今後理解をするとよいもの
- ローダーの概念
- webpackの機能
- コンパイルとバンドルの使い分け
